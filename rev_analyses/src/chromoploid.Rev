
#
# Joint model of chromosome number evolution and ploidy. Diploid/polyploid
# is treated as a hidden state and diversification rates are estimated separately
# for diploid/polyploid.
#
# by Will Freyman
# willfreyman@gmail.com
#



# analysis settings
analysis_name = "sol"
#rep = 1
base_dir = ""
mcmc_iterations = 2500
burnin = 0
sample_freq = 1
mi = 1
max_chromo = 94
total_species = 2700
setOption("useScaling", "true")

rediploid = TRUE
sample_ancestral_states = TRUE
sample_stochastic_maps = FALSE



# read in data
psi <- readTrees(base_dir + "data/soltreealltaxa.tre")[1]
raw_data = readCharacterDataDelimited(base_dir + "data/chromo_counts.tsv", 
                                      stateLabels=(max_chromo + 1), 
                                      type="NaturalNumbers", 
                                      delimiter="\t", 
                                      headers=FALSE)

chromo_data = raw_data.expandCharacters( 2 )

t_len <- psi.treeLength()
rate_pr := t_len / 2



# first set up anagenetic transition rates
for (i in 1:2) {

    # anagenetic rate of chromosome gains
    gamma[i] ~ dnExponential(rate_pr)

    # anagenetic rate of chromosome losses
    delta[i] ~ dnExponential(rate_pr)

    # anagenetic rate of polyploidization
    rho[i] ~ dnExponential(rate_pr)

    # anagenetic rate of demi-polyploidization
    eta[i] <- 0.0

    gamma_l[i] <- 0.0
    delta_l[i] <- 0.0
    
    moves[mi++] = mvScale(gamma[i], lambda=1.0, weight=2)
    moves[mi++] = mvScale(delta[i], lambda=1.0, weight=2)
    moves[mi++] = mvScale(rho[i], lambda=1.0, weight=2)

}

if (rediploid == TRUE) {

    rediploidization ~ dnExponential(rate_pr * 10)
    moves[mi++] = mvScale(rediploidization, lambda=1.0, weight=2)

} else {

    rediploidization <- 0.0

}

# create the rate matrix for anagenetic transitions
R := fnChromosomesPloidy(max_chromo, 
                         gamma[1], 
                         delta[1], 
                         rho[1], 
                         eta[1], 
                         gamma_l[1], 
                         delta_l[1], 
                         gamma[2], 
                         delta[2], 
                         rho[2], 
                         eta[2], 
                         gamma_l[2], 
                         delta_l[2], 
                         rediploidization)



# speciation and extinction rates

speciation_mean <- abs( ln( total_species / 2.0 ) / psi.rootAge() )

# separate rates for diploid and polyploid lineages
for (i in 1:2) {

    clado_no_change[i] ~ dnLognormal(ln(speciation_mean), 1)
    mu[i] ~ dnLognormal(ln(speciation_mean), 1)

    # rates of cladogenetic change
    clado_fission[i] ~ dnExponential(rate_pr)
    clado_fusion[i] ~ dnExponential(rate_pr)
    clado_polyploid[i] ~ dnExponential(rate_pr)
    clado_demipoly[i] <- 0.0

    # MCMC moves for speciation rates
    moves[mi++] = mvScale(clado_no_change[i], lambda=5.0, weight=2)
    moves[mi++] = mvScale(clado_fission[i], lambda=5.0, weight=2)
    moves[mi++] = mvScale(clado_fusion[i], lambda=5.0, weight=2)
    moves[mi++] = mvScale(clado_polyploid[i], lambda=5.0, weight=2)
    moves[mi++] = mvScale(mu[i], lambda=5.0, weight=2)

    up_down_scale_mv[i] = mvUpDownScale(lambda=0.5, weight=5)
    up_down_scale_mv[i].addVariable( clado_no_change[i], TRUE )
    up_down_scale_mv[i].addVariable( mu[i], TRUE )
    moves[mi++] = up_down_scale_mv[i]

}

speciation_rates := [clado_no_change[1], clado_fission[1], clado_fusion[1], clado_polyploid[1], clado_demipoly[1],
                     clado_no_change[2], clado_fission[2], clado_fusion[2], clado_polyploid[2], clado_demipoly[2]]

# map the speciation rates to chromosome cladogenetic events
clado_matrix := fnChromosomesPloidyCladoEventsBD(speciation_rates, max_chromo)

# variables for easy monitoring
speciation_diploid := sum([clado_no_change[1], clado_fission[1], clado_fusion[1], clado_polyploid[1], clado_demipoly[1]])
speciation_polyploid := sum([clado_no_change[2], clado_fission[2], clado_fusion[2], clado_polyploid[2], clado_demipoly[2]])
extinction_diploid := mu[1]
extinction_polyploid := mu[2]
diversification_diploid := speciation_diploid - extinction_diploid
diversification_polyploid := speciation_polyploid - extinction_polyploid

# make a vector of extinction rates for each state
for (i in 1:(max_chromo + 1)) {
    extinction[i] := extinction_diploid
}
for (i in (max_chromo + 2):(2 * (max_chromo + 1))) {
    extinction[i] := extinction_polyploid
}




# set up root frequencies
for (i in 1:(max_chromo + 1)) {
    root_frequencies_prior[i] <- 1.0
}
for (i in (max_chromo + 2):(2 * (max_chromo + 1))) {
    #root_frequencies_prior[i] <- 0.01
    root_frequencies_prior[i] <- 0.0
}
root_frequencies <- simplex(root_frequencies_prior)
#root_frequencies ~ dnDirichlet(root_frequencies_prior)
#moves[mi++] = mvBetaSimplex(root_frequencies, alpha=0.5, weight=5)
#moves[mi++] = mvElementSwapSimplex(root_frequencies, weight=5)



# construct a variable for the tree and chromosomes drawn from a 
# cladogenetic character state dependent birth death process
rho_s <- Probability(psi.ntips()/total_species)
chromotree ~ dnCDCladoBDP(rootAge                   = psi.rootAge(),
                          cladoEventMap             = clado_matrix,
                          extinctionRates           = extinction, 
                          Q                         = R,
                          pi                        = root_frequencies,
                          rho                       = rho_s)

# and clamp tree and the chromosome counts data
chromotree.clamp(psi)
chromotree.clampCharData(chromo_data)

mymodel = model(chromotree)



# set up and run MCMC
mni = 1
monitors[mni++] = mnScreen(printgen=sample_freq, 
                       speciation_diploid, 
                       speciation_polyploid, 
                       extinction_diploid, 
                       extinction_polyploid, 
                       diversification_diploid, 
                       diversification_polyploid)
monitors[mni++] = mnModel(filename=base_dir + "output/" + analysis_name + rep + ".log", 
                      printgen=sample_freq)
if (sample_ancestral_states == TRUE) {
    monitors[mni++] = mnJointConditionalAncestralState(tree=psi, 
                                                       cdbdp=chromotree, 
                                                       type="NaturalNumbers", 
                                                       printgen=sample_freq, 
                                                       withTips=TRUE, 
                                                       withStartStates=TRUE, 
                                                       filename="output/" + analysis_name + rep + "_anc.log")
}
if (sample_stochastic_maps == TRUE) {
    monitors[mni++] = mnStochasticCharacterMap(cdbdp=chromotree, 
                                               printgen=sample_freq, 
                                               filename=base_dir + "output/" + analysis_name + rep + "_map.log", 
                                               include_simmap=TRUE)
}

mymcmc = mcmc(mymodel, monitors, moves)
mymcmc.run(generations=mcmc_iterations)

q()
